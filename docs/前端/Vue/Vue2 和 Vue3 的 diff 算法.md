Vue 2 和 Vue 3 的 **Diff 算法**（虚拟 DOM 对比算法）在核心思路上相似，但 Vue 3 通过优化策略显著提升了性能。以下是两者的具体实现逻辑和差异：

---

### **1. Vue 2 的 Diff 算法**
**核心策略**：递归对比新旧虚拟 DOM 树的节点，采用 **双端比较**（头尾指针法）减少操作次数。  
**具体步骤**：
1. **同级比较**：仅对比同一层级的节点，不跨层级（时间复杂度 O(n)）。
2. **双端指针**：使用 4 个指针（旧头、旧尾、新头、新尾）依次比较：
   - 头头相同：直接复用，指针后移。
   - 尾尾相同：直接复用，指针前移。
   - 旧头与新尾相同：移动节点到旧尾后，指针调整。
   - 旧尾与新头相同：移动节点到旧头前，指针调整。
3. **Key 优化**：若节点有唯一 `key`，通过哈希映射快速查找可复用节点。
4. **暴力对比**：若以上均不匹配，遍历旧节点查找新头节点，找到则移动，否则新建节点。

**缺点**：
- 全量递归对比，存在不必要的子树遍历。
- 移动 DOM 时可能产生冗余操作（如顺序调整时多次移动）。

---

### **2. Vue 3 的 Diff 算法**
**核心优化**：引入 **静态标记（PatchFlag）** 和 **最长递增子序列（LIS）**，减少无效对比。  
**具体改进**：
1. **静态提升（Hoist Static）**：  
   - 编译时标记静态节点（如纯文本），跳过 Diff 直接复用。
2. **PatchFlag 标记**：  
   - 动态节点被标记（如 `class` 变化、`props` 变化），仅对比动态部分。
3. **Block Tree 优化**：  
   - 将动态节点按区块（Block）组织，减少递归深度。
4. **最长递增子序列（LIS）**：  
   - 在节点顺序调整时，通过 LIS 算法找到最长无需移动的序列，最小化 DOM 操作。

**对比流程**：
1. **预处理**：跳过静态节点，仅处理动态区块。
2. **双端比较**：类似 Vue 2，但优先处理 PatchFlag 标记的节点。
3. **LIS 优化**：  
   - 若新节点顺序变化，计算新旧子序列的最长递增子序列，仅移动非递增节点。

**优势**：
- 减少 50% 以上的虚拟 DOM 对比时间^[Vue 3 官方数据]^。
- 更精准的 DOM 操作，避免冗余更新。

---

### **关键差异总结**
| 特性                | Vue 2                          | Vue 3                          |
|---------------------|-------------------------------|-------------------------------|
| **核心策略**         | 双端比较 + 暴力遍历            | 双端比较 + LIS + 静态标记      |
| **静态节点处理**     | 无优化，全量对比               | 编译时静态提升，跳过 Diff      |
| **动态节点标记**     | 无                            | PatchFlag 精准定位变化         |
| **顺序调整优化**     | 可能多次移动                   | LIS 算法最小化移动次数         |
| **时间复杂度**       | O(n)（实际性能较低）           | O(n)（实际性能更高）           |

---

### **示例场景**
假设新旧子节点顺序从 `[A, B, C, D]` 变为 `[D, A, B, C]`：
- **Vue 2**：可能移动 3 次（D→头部，A/B/C 依次后移）。
- **Vue 3**：通过 LIS 发现 `[A, B, C]` 是递增序列，仅移动 `D` 到头部。

---

### **总结**
Vue 3 的 Diff 算法通过编译时优化和运行时策略（如 LIS），显著减少了不必要的计算和 DOM 操作。若需深入代码细节，可参考 Vue 3 源码中的 `packages/runtime-core/src/renderer.ts` 的 `patchChildren` 方法。