import{_ as i,c as a,o as t,ag as n}from"./chunks/framework.C4SRkA9c.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端/JS/JS复制与赋值.md","filePath":"前端/JS/JS复制与赋值.md","lastUpdated":1761188845000}'),l={name:"前端/JS/JS复制与赋值.md"};function h(e,s,o,p,k,r){return t(),a("div",null,[...s[0]||(s[0]=[n(`<p>在 JavaScript/TypeScript 中，<strong>赋值（Assignment）</strong> 和 <strong>复制（Copying）</strong> 是两种不同的操作，主要区别在于对 <strong>原始数据类型（Primitive Types）</strong> 和 <strong>引用数据类型（Reference Types）</strong> 的处理方式。</p><hr><h2 id="_1-赋值-assignment" tabindex="-1"><strong>1. 赋值（Assignment）</strong> <a class="header-anchor" href="#_1-赋值-assignment" aria-label="Permalink to &quot;**1. 赋值（Assignment）**&quot;">​</a></h2><p><strong>赋值</strong> 是指将一个变量存储的值（原始值或引用地址）直接传递给另一个变量。</p><ul><li><strong>原始数据类型（<code>number</code>, <code>string</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code>, <code>bigint</code>）</strong>： <ul><li>赋值时传递的是 <strong>值的副本</strong>，修改新变量不会影响原变量。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 赋值（b 是 a 的副本）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 10（a 不受影响）</span></span></code></pre></div></li><li><strong>引用数据类型（<code>object</code>, <code>array</code>, <code>function</code>）</strong>： <ul><li>赋值时传递的是 <strong>内存地址的引用</strong>，修改新变量会影响原变量。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj1; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 赋值（obj2 和 obj1 指向同一内存地址）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj2.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Bob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj1.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;Bob&quot;（obj1 也被修改）</span></span></code></pre></div></li></ul><p><strong>总结</strong>：</p><ul><li><strong>原始类型赋值</strong>：复制值，新旧变量独立。</li><li><strong>引用类型赋值</strong>：复制引用，新旧变量共享同一对象。</li></ul><hr><h2 id="_2-复制-copying" tabindex="-1"><strong>2. 复制（Copying）</strong> <a class="header-anchor" href="#_2-复制-copying" aria-label="Permalink to &quot;**2. 复制（Copying）**&quot;">​</a></h2><p><strong>复制</strong> 是指创建一个新对象，并复制原对象的所有属性（可能涉及 <strong>浅拷贝</strong> 或 <strong>深拷贝</strong>）。</p><h3 id="_1-浅拷贝-shallow-copy" tabindex="-1"><strong>(1) 浅拷贝（Shallow Copy）</strong> <a class="header-anchor" href="#_1-浅拷贝-shallow-copy" aria-label="Permalink to &quot;**(1) 浅拷贝（Shallow Copy）**&quot;">​</a></h3><ul><li>仅复制对象的第一层属性，嵌套对象仍然是引用共享。</li><li><strong>方法</strong>： <ul><li><code>Object.assign({}, obj)</code></li><li><code>{ ...obj }</code>（扩展运算符）</li><li><code>arr.slice()</code></li><li><code>[...arr]</code></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: { c: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj1 }; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 浅拷贝</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj2.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不影响 obj1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj2.b.c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 会影响 obj1.b.c</span></span></code></pre></div><strong>影响</strong>： <ul><li>修改 <code>obj2.a</code> 不影响 <code>obj1.a</code>（第一层独立）。</li><li>修改 <code>obj2.b.c</code> 会影响 <code>obj1.b.c</code>（嵌套对象共享引用）。</li></ul></li></ul><h3 id="_2-深拷贝-deep-copy" tabindex="-1"><strong>(2) 深拷贝（Deep Copy）</strong> <a class="header-anchor" href="#_2-深拷贝-deep-copy" aria-label="Permalink to &quot;**(2) 深拷贝（Deep Copy）**&quot;">​</a></h3><ul><li>递归复制所有层级，新旧对象完全独立。</li><li><strong>方法</strong>： <ul><li><code>JSON.parse(JSON.stringify(obj))</code>（不支持 <code>function</code>、<code>Symbol</code>、循环引用）</li><li><code>structuredClone()</code>（现代浏览器 API）</li><li>Lodash 的 <code>_.cloneDeep()</code></li><li>手动递归实现</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: { c: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj1)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 深拷贝</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj2.b.c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不影响 obj1.b.c</span></span></code></pre></div><strong>影响</strong>： <ul><li>修改 <code>obj2</code> 的任何属性都不会影响 <code>obj1</code>。</li></ul></li></ul><hr><h2 id="_3-赋值-vs-复制-对比" tabindex="-1"><strong>3. 赋值 vs 复制 对比</strong> <a class="header-anchor" href="#_3-赋值-vs-复制-对比" aria-label="Permalink to &quot;**3. 赋值 vs 复制 对比**&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>操作</strong></th><th><strong>原始类型</strong></th><th><strong>引用类型</strong></th><th><strong>影响</strong></th></tr></thead><tbody><tr><td><strong>赋值</strong></td><td>复制值</td><td>复制引用</td><td>修改新变量会影响原对象</td></tr><tr><td><strong>浅拷贝</strong></td><td>不适用</td><td>仅复制第一层</td><td>修改嵌套对象会影响原对象</td></tr><tr><td><strong>深拷贝</strong></td><td>不适用</td><td>复制所有层级</td><td>新旧对象完全独立</td></tr></tbody></table><hr><h2 id="_4-如何选择" tabindex="-1"><strong>4. 如何选择？</strong> <a class="header-anchor" href="#_4-如何选择" aria-label="Permalink to &quot;**4. 如何选择？**&quot;">​</a></h2><ul><li><strong>赋值</strong>：适用于简单变量传递，但引用类型会共享内存。</li><li><strong>浅拷贝</strong>：适用于单层对象，性能较好。</li><li><strong>深拷贝</strong>：适用于嵌套对象，确保数据隔离（但性能较低）。</li></ul><hr><h2 id="_5-总结" tabindex="-1"><strong>5. 总结</strong> <a class="header-anchor" href="#_5-总结" aria-label="Permalink to &quot;**5. 总结**&quot;">​</a></h2><ul><li><strong>赋值</strong>：直接传递值或引用，引用类型会共享内存。</li><li><strong>复制</strong>： <ul><li><strong>浅拷贝</strong>：仅复制第一层，嵌套对象仍共享。</li><li><strong>深拷贝</strong>：完全独立复制所有层级。</li></ul></li></ul><p><strong>关键点</strong>：</p><ul><li><strong>原始类型</strong>：赋值即复制，新旧变量独立。</li><li><strong>引用类型</strong>： <ul><li>赋值 → 共享引用。</li><li>浅拷贝 → 第一层独立，嵌套共享。</li><li>深拷贝 → 完全独立。</li></ul></li></ul>`,25)])])}const c=i(l,[["render",h]]);export{g as __pageData,c as default};
