import{_ as r,c as o,o as e,ag as l}from"./chunks/framework.C4SRkA9c.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端/Vue/Vue2 和 Vue3 的 diff 算法.md","filePath":"前端/Vue/Vue2 和 Vue3 的 diff 算法.md","lastUpdated":1761188845000}'),n={name:"前端/Vue/Vue2 和 Vue3 的 diff 算法.md"};function i(s,t,a,d,g,u){return e(),o("div",null,[...t[0]||(t[0]=[l('<p>Vue 2 和 Vue 3 的 <strong>Diff 算法</strong>（虚拟 DOM 对比算法）在核心思路上相似，但 Vue 3 通过优化策略显著提升了性能。以下是两者的具体实现逻辑和差异：</p><hr><h3 id="_1-vue-2-的-diff-算法" tabindex="-1"><strong>1. Vue 2 的 Diff 算法</strong> <a class="header-anchor" href="#_1-vue-2-的-diff-算法" aria-label="Permalink to &quot;**1. Vue 2 的 Diff 算法**&quot;">​</a></h3><p><strong>核心策略</strong>：递归对比新旧虚拟 DOM 树的节点，采用 <strong>双端比较</strong>（头尾指针法）减少操作次数。<br><strong>具体步骤</strong>：</p><ol><li><strong>同级比较</strong>：仅对比同一层级的节点，不跨层级（时间复杂度 O(n)）。</li><li><strong>双端指针</strong>：使用 4 个指针（旧头、旧尾、新头、新尾）依次比较： <ul><li>头头相同：直接复用，指针后移。</li><li>尾尾相同：直接复用，指针前移。</li><li>旧头与新尾相同：移动节点到旧尾后，指针调整。</li><li>旧尾与新头相同：移动节点到旧头前，指针调整。</li></ul></li><li><strong>Key 优化</strong>：若节点有唯一 <code>key</code>，通过哈希映射快速查找可复用节点。</li><li><strong>暴力对比</strong>：若以上均不匹配，遍历旧节点查找新头节点，找到则移动，否则新建节点。</li></ol><p><strong>缺点</strong>：</p><ul><li>全量递归对比，存在不必要的子树遍历。</li><li>移动 DOM 时可能产生冗余操作（如顺序调整时多次移动）。</li></ul><hr><h3 id="_2-vue-3-的-diff-算法" tabindex="-1"><strong>2. Vue 3 的 Diff 算法</strong> <a class="header-anchor" href="#_2-vue-3-的-diff-算法" aria-label="Permalink to &quot;**2. Vue 3 的 Diff 算法**&quot;">​</a></h3><p><strong>核心优化</strong>：引入 <strong>静态标记（PatchFlag）</strong> 和 <strong>最长递增子序列（LIS）</strong>，减少无效对比。<br><strong>具体改进</strong>：</p><ol><li><strong>静态提升（Hoist Static）</strong>： <ul><li>编译时标记静态节点（如纯文本），跳过 Diff 直接复用。</li></ul></li><li><strong>PatchFlag 标记</strong>： <ul><li>动态节点被标记（如 <code>class</code> 变化、<code>props</code> 变化），仅对比动态部分。</li></ul></li><li><strong>Block Tree 优化</strong>： <ul><li>将动态节点按区块（Block）组织，减少递归深度。</li></ul></li><li><strong>最长递增子序列（LIS）</strong>： <ul><li>在节点顺序调整时，通过 LIS 算法找到最长无需移动的序列，最小化 DOM 操作。</li></ul></li></ol><p><strong>对比流程</strong>：</p><ol><li><strong>预处理</strong>：跳过静态节点，仅处理动态区块。</li><li><strong>双端比较</strong>：类似 Vue 2，但优先处理 PatchFlag 标记的节点。</li><li><strong>LIS 优化</strong>： <ul><li>若新节点顺序变化，计算新旧子序列的最长递增子序列，仅移动非递增节点。</li></ul></li></ol><p><strong>优势</strong>：</p><ul><li>减少 50% 以上的虚拟 DOM 对比时间^[Vue 3 官方数据]^。</li><li>更精准的 DOM 操作，避免冗余更新。</li></ul><hr><h3 id="关键差异总结" tabindex="-1"><strong>关键差异总结</strong> <a class="header-anchor" href="#关键差异总结" aria-label="Permalink to &quot;**关键差异总结**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>Vue 2</th><th>Vue 3</th></tr></thead><tbody><tr><td><strong>核心策略</strong></td><td>双端比较 + 暴力遍历</td><td>双端比较 + LIS + 静态标记</td></tr><tr><td><strong>静态节点处理</strong></td><td>无优化，全量对比</td><td>编译时静态提升，跳过 Diff</td></tr><tr><td><strong>动态节点标记</strong></td><td>无</td><td>PatchFlag 精准定位变化</td></tr><tr><td><strong>顺序调整优化</strong></td><td>可能多次移动</td><td>LIS 算法最小化移动次数</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(n)（实际性能较低）</td><td>O(n)（实际性能更高）</td></tr></tbody></table><hr><h3 id="示例场景" tabindex="-1"><strong>示例场景</strong> <a class="header-anchor" href="#示例场景" aria-label="Permalink to &quot;**示例场景**&quot;">​</a></h3><p>假设新旧子节点顺序从 <code>[A, B, C, D]</code> 变为 <code>[D, A, B, C]</code>：</p><ul><li><strong>Vue 2</strong>：可能移动 3 次（D→头部，A/B/C 依次后移）。</li><li><strong>Vue 3</strong>：通过 LIS 发现 <code>[A, B, C]</code> 是递增序列，仅移动 <code>D</code> 到头部。</li></ul><hr><h3 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><p>Vue 3 的 Diff 算法通过编译时优化和运行时策略（如 LIS），显著减少了不必要的计算和 DOM 操作。若需深入代码细节，可参考 Vue 3 源码中的 <code>packages/runtime-core/src/renderer.ts</code> 的 <code>patchChildren</code> 方法。</p>',25)])])}const f=r(n,[["render",i]]);export{h as __pageData,f as default};
